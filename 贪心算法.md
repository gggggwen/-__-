# 贪心算法





##    1.有关数字序列(坡度问题)

###    1.1 [leetcode378 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/description/)

![image-20240725112702893](./photo/image-20240725112702893.png)

摆动序列有三种情况:上坡  下坡  平坡

默认在nums中有一个元素则  res = 1 ,仅有一个 上坡或下坡 res =2

- 首先判断数组元素个数是否为1 

  ```c++
  if(nums.size()==1) return 1 ;
  ```

- 若不为1 ,开始进行初始化

  ```c++
  int pre_diff = 0 ;//假设在nums[0] 前有 nums[-1] 且nums[0]=nums[-1]
  int cur_diff  ; //进入循环再初始化也不迟
  int idx = 0;
  int res =1 ;
  ```

- 进入循环,也是本题的关键

  ```c++
  while(idx+1 <nums.size())
  {
      //每次循环前初始化 cur_diff
      cur_diff = nums[idx+1] - nums[idx];
      if(cur_diff>0 && pre_diff<=0 || cur_diff<0 && pre_diff>=0) //pre可取等               {
           res++ ;
           pre_diff = cur_diff; //只有遇到了拐点再更新pre 就无需考虑一直上坡或者出现平坡的情况
        } 
      idx++;
  }
  ```





###    1.2 [leetcode 738 单调递增的数字]( https://leetcode.cn/problems/monotone-increasing-digits/description/ )-----上坡

- ![738](./photo/738.png)
- **大致思路**:
  1. 找到下坡的位置 即第一个：`strn[idx]<strn[idx-1]`的位置
  2. 若一直是非下坡 直接return
  3. 尝试反向遍历字符串整数若满足`strn[idx-1]>strn[idx]`则对`strn[idx-1]--`
  4. 最后遍历终止 ,将后面所有位数变为'9'

```
class Solution {
public:
    int monotoneIncreasingDigits(int n)
    {
        string strn = to_string(n);
        int idx = 1 ;
        while( idx<strn.size() && strn[idx]>=strn[idx-1] )
        {
            idx++; 
        }
        if(idx>=strn.size()) return stoi(strn);

        while(idx>0 && strn[idx]<strn[idx-1])
        {
            strn[idx-1]--;
            idx--;
        }
        idx++;
        while(idx<strn.size())
        {
            strn[idx]='9';
            idx++;
        }
        return stoi(strn);
    }
};
```

注意第二次判定时,不能对`nums[idx]`进行减减操作 ,最后会<font color=red>**导致指针越界!!**</font>